<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>PreloadJS v0.4.1 API Documentation : preloadjs/LoadQueue.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="http://www.createjs.com/#!/PreloadJS"><img src="../assets/docs-icon-PreloadJS.png" title="PreloadJS"></a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.4.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AbstractLoader.html">AbstractLoader</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/EventDispatcher.html">EventDispatcher</a></li>
            
                <li><a href="../classes/LoadQueue.html">LoadQueue</a></li>
            
                <li><a href="../classes/PreloadJS.html">PreloadJS</a></li>
            
                <li><a href="../classes/SamplePlugin.html">SamplePlugin</a></li>
            
                <li><a href="../classes/TagLoader.html">TagLoader</a></li>
            
                <li><a href="../classes/Utility Methods.html">Utility Methods</a></li>
            
                <li><a href="../classes/XHRLoader.html">XHRLoader</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CreateJS.html">CreateJS</a></li>
            
                <li><a href="../modules/PreloadJS.html">PreloadJS</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = preloadjs/LoadQueue.js      
</script>
<h1 class="file-heading">File:LoadQueue.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
* LoadQueue
* Visit http://createjs.com/ for documentation, updates and examples.
*
*
* Copyright (c) 2012 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the &quot;Software&quot;), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 * PreloadJS provides a consistent way to preload content for use in HTML applications. Preloading can be done using
 * HTML tags, as well as XHR.
 *
 * By default, PreloadJS will try and load content using XHR, since it provides better support for progress and
 * completion events, &lt;b&gt;however due to cross-domain issues, it may still be preferable to use tag-based loading
 * instead&lt;/b&gt;. Note that some content requires XHR to work (plain text, web audio), and some requires tags (HTML audio).
 * Note this is handled automatically where possible.
 *
 * PreloadJS currently supports all modern browsers, and we have done our best to include support for most older
 * browsers. If you find an issue with any specific OS/browser combination, please visit http://community.createjs.com/
 * and report it.
 *
 * &lt;h4&gt;Getting Started&lt;/h4&gt;
 * To get started, check out the {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} class, which includes a quick overview of how
 * to load files and process results.
 *
 * &lt;h4&gt;Example&lt;/h4&gt;
 *
 *      var queue = new createjs.LoadQueue();
 *      queue.installPlugin(createjs.Sound);
 *      queue.on(&quot;complete&quot;, handleComplete, this);
 *      queue.loadFile({id:&quot;sound&quot;, src:&quot;http://path/to/sound.mp3&quot;});
 *      queue.loadManifest([
 *          {id: &quot;myImage&quot;, src:&quot;path/to/myImage.jpg&quot;}
 *      ]);
 *      function handleComplete() {
 *          createjs.Sound.play(&quot;sound&quot;);
 *          var image = queue.getResult(&quot;myImage&quot;);
 *          document.body.appendChild(image);
 *      }
 *
 * &lt;b&gt;Important note on plugins:&lt;/b&gt; Plugins must be installed &lt;i&gt;before&lt;/i&gt; items are added to the queue, otherwise
 * they will not be processed, even if the load has not actually kicked off yet. Plugin functionality is handled when
 * the items are added to the LoadQueue.
 *
 * &lt;h4&gt;Browser Support&lt;/h4&gt;
 * PreloadJS is partially supported in all browsers, and fully supported in all modern browsers. Known exceptions:
 * &lt;ul&gt;&lt;li&gt;XHR loading of any content will not work in many older browsers (See a matrix here: &lt;a href=&quot;http://caniuse.com/xhr2&quot; target=&quot;_blank&quot;&gt;http://caniuse.com/xhr2&lt;/a&gt;).
 *      In many cases, you can fall back on tag loading (images, audio, CSS, scripts, SVG, and JSONP). Text and
 *      WebAudio will only work with XHR.&lt;/li&gt;
 *      &lt;li&gt;Some formats have poor support for complete events in IE 6, 7, and 8 (SVG, tag loading of scripts, XML/JSON)&lt;/li&gt;
 *      &lt;li&gt;Opera has poor support for SVG loading with XHR&lt;/li&gt;
 *      &lt;li&gt;CSS loading in Android and Safari will not work with tags (currently, a workaround is in progress)&lt;/li&gt;
 *      &lt;li&gt;Local loading is not permitted with XHR, which is required by some file formats. When testing local content
 *      use either a local server, or enable tag loading, which is supported for most formats. See {{#crossLink &quot;LoadQueue/setUseXHR&quot;}}{{/crossLink}}
 *      for more information.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h4&gt;Cross-domain Loading&lt;/h4&gt;
 * Most content types can be loaded cross-domain, as long as the server supports CORS. PreloadJS also has internal
 * support for images served from a CORS-enabled server, via the &#x60;crossOrigin&#x60; argument on the {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}}
 * constructor. If set to a string value (such as &quot;Anonymous&quot;), the &quot;crossOrigin&quot; property of images generated by
 * PreloadJS is set to that value. Please note that setting a &#x60;crossOrigin&#x60; value on an image that is served from a
 * server without CORS will cause other errors. For more info on CORS, visit https://en.wikipedia.org/wiki/Cross-origin_resource_sharing.
 *
 * @module PreloadJS
 * @main PreloadJS
 */

// namespace:
this.createjs = this.createjs||{};

/*
TODO: WINDOWS ISSUES
	* No error for HTML audio in IE 678
	* SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
	* No script complete handler in IE 67 TAGS (XHR is fine)
	* No XML/JSON in IE6 TAGS
	* Need to hide loading SVG in Opera TAGS
	* No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
	* SVG no load or failure in Opera XHR
	* Reported issues with IE7/8
 */

(function() {
	&quot;use strict&quot;;

	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * &lt;b&gt;Creating a Queue&lt;/b&gt;&lt;br /&gt;
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the useXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * &lt;b&gt;Listening for Events&lt;/b&gt;&lt;br /&gt;
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink &quot;EventDispatcher&quot;}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:&lt;ul&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/complete:event&quot;}}{{/crossLink}}: fired when a queue completes loading all
	 *     files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/error:event&quot;}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/progress:event&quot;}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}: A single file has completed loading.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/fileprogress:event&quot;}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 *      queue.on(&quot;fileload&quot;, handleFileLoad, this);
	 *      queue.on(&quot;complete&quot;, handleComplete, this);
	 *
	 * &lt;b&gt;Adding files and manifests&lt;/b&gt;&lt;br /&gt;
	 * Add files you want to load using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile(&quot;filePath/file.jpg&quot;);
	 *      queue.loadFile({id:&quot;image&quot;, src:&quot;filePath/file.jpg&quot;});
	 *      queue.loadManifest([&quot;filePath/file.jpg&quot;, {id:&quot;image&quot;, src:&quot;filePath/file.jpg&quot;}];
	 *
	 * If you pass &#x60;false&#x60; as the &#x60;loadNow&#x60; parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink &quot;AbstractLoader/load&quot;}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * &#x60;loadNow&#x60; argument of &#x60;true&#x60;.
	 *
	 *      queue.load();
	 *
	 * &lt;b&gt;File Types&lt;/b&gt;&lt;br /&gt;
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * &lt;code&gt;type&lt;/code&gt; property with any manifest item.
	 *
	 *      queue.loadFile({src:&quot;path/to/myFile.mp3x&quot;, type:createjs.LoadQueue.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:&quot;http://server.com/proxy?file=image.jpg&quot;}, type:createjs.LoadQueue.IMAGE});
	 *
	 * Supported types are defined on the LoadQueue class, and include:
	 * &lt;ul&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/BINARY:property&quot;}}{{/crossLink}}: Raw binary data via XHR&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/CSS:property&quot;}}{{/crossLink}}: CSS files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/IMAGE:property&quot;}}{{/crossLink}}: Common image formats&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/JAVASCRIPT:property&quot;}}{{/crossLink}}: JavaScript files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/JSON:property&quot;}}{{/crossLink}}: JSON data&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/JSONP:property&quot;}}{{/crossLink}}: JSON files cross-domain&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/MANIFEST:property&quot;}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/SOUND:property&quot;}}{{/crossLink}}: Audio file formats&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/SVG:property&quot;}}{{/crossLink}}: SVG files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/TEXT:property&quot;}}{{/crossLink}}: Text files - XHR only&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/XML:property&quot;}}{{/crossLink}}: XML data&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;b&gt;Handling Results&lt;/b&gt;&lt;br /&gt;
	 * When a file is finished downloading, a {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * resolved object that can be used immediately, including:
	 * &lt;ul&gt;
	 *     &lt;li&gt;Image: An &amp;lt;img /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;Audio: An &amp;lt;audio /&amp;gt; tag&lt;/a&gt;
	 *     &lt;li&gt;JavaScript: A &amp;lt;script /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;CSS: A &amp;lt;link /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;XML: An XML DOM node&lt;/li&gt;
	 *     &lt;li&gt;SVG: An &amp;lt;object /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;JSON: A formatted JavaScript Object&lt;/li&gt;
	 *     &lt;li&gt;Text: Raw text&lt;/li&gt;
	 *     &lt;li&gt;Binary: The binary loaded result&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.LoadQueue.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its &quot;id&quot; using {{#crossLink &quot;LoadQueue/getResult&quot;}}{{/crossLink}}. If no id was provided, then the &quot;src&quot; or
	 * file path can be used instead, including the &#x60;path&#x60; defined by a manifest, but &lt;strong&gt;not including&lt;/strong&gt; a
	 * base path defined on the LoadQueue. It is recommended to always pass an id.
	 *
	 *      var image = queue.getResult(&quot;image&quot;);
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the &lt;code&gt;rawResult&lt;/code&gt; property of the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink &quot;LoadQueue/getResult&quot;}}{{/crossLink}}, passing &#x60;true&#x60; as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult(&quot;image&quot;, true); // load the binary image data loaded with XHR.
	 *
	 * &lt;b&gt;Plugins&lt;/b&gt;&lt;br /&gt;
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the &lt;a href=&quot;http://soundjs.com&quot;&gt;SoundJS&lt;/a&gt; Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed &lt;strong&gt;before&lt;/strong&gt; loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * &lt;h4&gt;Known Browser Issues&lt;/h4&gt;
	 * &lt;ul&gt;
	 *     &lt;li&gt;Browsers without audio support can not load audio files.&lt;/li&gt;
	 *     &lt;li&gt;Safari on Mac OS X can only play HTML audio if QuickTime is installed&lt;/li&gt;
	 *     &lt;li&gt;HTML Audio tags will only download until their &lt;code&gt;canPlayThrough&lt;/code&gt; event is fired. Browsers other
	 *     than Chrome will continue to download in the background.&lt;/li&gt;
	 *     &lt;li&gt;When loading scripts using tags, they are automatically added to the document.&lt;/li&gt;
	 *     &lt;li&gt;Scripts loaded via XHR may not be properly inspectable with browser tools.&lt;/li&gt;
	 *     &lt;li&gt;IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.&lt;/li&gt;
	 *     &lt;li&gt;Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @class LoadQueue
	 * @param {Boolean} [useXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is &#x60;false&#x60;, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=&quot;&quot;] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as &#x60;http://&#x60; or a relative path such as &#x60;../&#x60;
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=&quot;&quot;] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to &#x60;true&#x60;, which will default the crossOrigin property on images to &quot;Anonymous&quot;. Any
	 * string value will be passed through, but only &quot;&quot; and &quot;Anonymous&quot; are recommended.
	 * @constructor
	 * @extends AbstractLoader
	 */
	var LoadQueue = function(useXHR, basePath, crossOrigin) {
		this.init(useXHR, basePath, crossOrigin);
	};

	var p = LoadQueue.prototype = new createjs.AbstractLoader();
	var s = LoadQueue;

	/**
	 * Time in milliseconds to assume a load has failed. An {{#crossLink &quot;AbstractLoader/error:event&quot;}}{{/crossLink}}
	 * event is dispatched if the timeout is reached before any data is received.
	 * @property loadTimeout
	 * @type {Number}
	 * @default 8000
	 * @static
	 * @since 0.4.1
	 */
	s.loadTimeout = 8000;

	/**
	 * Time in milliseconds to assume a load has failed.
	 * @type {Number}
	 * @deprecated in favor of the {{#crossLink &quot;LoadQueue/loadTimeout:property&quot;}}{{/crossLink}} property.
	 */
	s.LOAD_TIMEOUT = 0;

// Preload Types
	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 */
	s.BINARY = &quot;binary&quot;;

	/**
	 * The preload type for css files. CSS files are loaded using a &amp;lt;link&amp;gt; when loaded with XHR, or a
	 * &amp;lt;style&amp;gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 */
	s.CSS = &quot;css&quot;;

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &amp;lt;image&amp;gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 */
	s.IMAGE = &quot;image&quot;;

	/**
	 * The preload type for javascript files, usually with the &quot;js&quot; file extension. JavaScript files are loaded into a
	 * &amp;lt;script&amp;gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 */
	s.JAVASCRIPT = &quot;javascript&quot;;

	/**
	 * The preload type for json files, usually with the &quot;json&quot; file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a &#x60;callback&#x60; is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink &quot;LoadQueue/useXHR:property&quot;}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 */
	s.JSON = &quot;json&quot;;

	/**
	 * The preload type for jsonp files, usually with the &quot;json&quot; file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink &quot;LoadQueue/useXHR:property&quot;}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 */
	s.JSONP = &quot;jsonp&quot;;

	/**
	 * The preload type for json-based manifest files, usually with the &quot;json&quot; file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a &quot;manifest&quot; property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}
	 * method. If a &quot;callback&quot; is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink &quot;LoadQueue/useXHR:property&quot;}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.4.1
	 */
	s.MANIFEST = &quot;manifest&quot;;

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &amp;lt;audio&amp;gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 */
	s.SOUND = &quot;sound&quot;;

	/**
     * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 */
	s.SVG = &quot;svg&quot;;

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 */
	s.TEXT = &quot;text&quot;;

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 */
	s.XML = &quot;xml&quot;;

	/**
	 * Defines a POST request, use for a method value when loading data.
	 *
	 * @type {string}
	 */
	s.POST = &#x27;POST&#x27;;

	/**
	 * Defines a GET request, use for a method value when loading data.
	 *
	 * @type {string}
	 */
	s.GET = &#x27;GET&#x27;;


// Prototype
	/**
	 * A path that will be prepended on to the item&#x27;s &#x60;src&#x60;. The &#x60;_basePath&#x60; property will only be used if an item&#x27;s
	 * source is relative, and does not include a protocol such as &#x60;http://&#x60;, or a relative path such as &#x60;../&#x60;.
	 * @property _basePath
	 * @type {String}
	 * @private
	 * @since 0.3.1
	 */
	p._basePath = null;

	/**
	 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
	 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
	 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
	 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are &quot;&quot;
	 * and &quot;Anonymous&quot;.
	 * @property _crossOrigin
	 * @type {String}
	 * @defaultValue &quot;&quot;
	 * @private
	 * @since 0.4.1
	 */
	p._crossOrigin = &quot;&quot;;

	/**
	 * Use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR loading depending
	 * on the requirements for a media type. For example, HTML audio can not be loaded with XHR, and WebAudio can not be
	 * loaded with tags, so it will default the the correct type instead of using the user-defined type.
	 *
	 * &lt;b&gt;Note: This property is read-only.&lt;/b&gt; To change it, please use the {{#crossLink &quot;LoadQueue/setUseXHR&quot;}}{{/crossLink}}
	 * method, or specify the &#x60;useXHR&#x60; argument in the LoadQueue constructor.
	 *
	 * @property useXHR
	 * @type {Boolean}
	 * @readOnly
	 * @default true
	 */
	p.useXHR = true;

	/**
	 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
	 * @property stopOnError
	 * @type {Boolean}
	 * @default false
	 */
	p.stopOnError = false;

	/**
	 * Ensure loaded scripts &quot;complete&quot; in the order they are specified. Loaded scripts are added to the document head
	 * once they are loaded. Note that scripts loaded via tags will load one-at-a-time when this property is &#x60;true&#x60;.
	 * load one at a time
	 * @property maintainScriptOrder
	 * @type {Boolean}
	 * @default true
	 */
	p.maintainScriptOrder = true;

	/**
	 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
	 * {{#crossLink &quot;LoadQueue/stopOnError:property&quot;}}{{/crossLink}} is &#x60;true&#x60;, the next queue will not be processed.
	 * @property next
	 * @type {LoadQueue}
	 * @default null
	 */
	p.next = null;

// Events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a &#x60;src&#x60; property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an an individual file progress changes.
	 * @event fileprogress
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a &#x60;src&#x60; property.
	 * @param {Number} loaded The number of bytes that have been loaded. Note that this may just be a percentage of 1.
	 * @param {Number} total The total number of bytes. If it is unknown, the value is 1.
	 * @param {Number} progress The amount that has been loaded between 0 and 1.
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

	//TODO: Deprecated
	/**
	 * REMOVED. Use {{#crossLink &quot;EventDispatcher/addEventListener&quot;}}{{/crossLink}} and the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}
	 * event.
	 * @property onFileLoad
	 * @type {Function}
	 * @deprecated Use addEventListener and the &quot;fileload&quot; event.
	 */
	/**
	 * REMOVED. Use {{#crossLink &quot;EventDispatcher/addEventListener&quot;}}{{/crossLink}} and the {{#crossLink &quot;LoadQueue/fileprogress:event&quot;}}{{/crossLink}}
	 * event.
	 * @property onFileProgress
	 * @type {Function}
	 * @deprecated Use addEventListener and the &quot;fileprogress&quot; event.
	 */


// Protected
	/**
	 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
	 * ability to override properties of the load. Please see the {{#crossLink &quot;LoadQueue/installPlugin&quot;}}{{/crossLink}}
	 * method for more information.
	 * @property _typeCallbacks
	 * @type {Object}
	 * @private
	 */
	p._typeCallbacks = null;

	/**
	 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
	 * ability to override properties of the load. Please see the {{#crossLink &quot;LoadQueue/installPlugin&quot;}}{{/crossLink}}
	 * method for more information.
	 * @property _extensionCallbacks
	 * @type {null}
	 * @private
	 */
	p._extensionCallbacks = null;

	/**
	 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
	 * file is requested.
	 * @property _loadStartWasDispatched
	 * @type {Boolean}
	 * @default false
	 * @private
	 */
	p._loadStartWasDispatched = false;

	/**
	 * The number of maximum open connections that a loadQueue tries to maintain. Please see
	 * {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}} for more information.
	 * @property _maxConnections
	 * @type {Number}
	 * @default 1
	 * @private
	 */
	p._maxConnections = 1;

	/**
	 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
	 * using a script tag to do preloading.
	 * @property _currentlyLoadingScript
	 * @type {Boolean}
	 * @private
	 */
	p._currentlyLoadingScript = null;

	/**
	 * An array containing the currently downloading files.
	 * @property _currentLoads
	 * @type {Array}
	 * @private
	 */
	p._currentLoads = null;

	/**
	 * An array containing the queued items that have not yet started downloading.
	 * @property _loadQueue
	 * @type {Array}
	 * @private
	 */
	p._loadQueue = null;

	/**
	 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
	 * @property _loadQueueBackup
	 * @type {Array}
	 * @private
	 */
	p._loadQueueBackup = null;

	/**
	 * An object hash of items that have finished downloading, indexed by item IDs.
	 * @property _loadItemsById
	 * @type {Object}
	 * @private
	 */
	p._loadItemsById = null;

	/**
	 * An object hash of items that have finished downloading, indexed by item source.
	 * @property _loadItemsBySrc
	 * @type {Object}
	 * @private
	 */
	p._loadItemsBySrc = null;

	/**
	 * An object hash of loaded items, indexed by the ID of the load item.
	 * @property _loadedResults
	 * @type {Object}
	 * @private
	 */
	p._loadedResults = null;

	/**
	 * An object hash of un-parsed loaded items, indexed by the ID of the load item.
	 * @property _loadedRawResults
	 * @type {Object}
	 * @private
	 */
	p._loadedRawResults = null;

	/**
	 * The number of items that have been requested. This helps manage an overall progress without knowing how large
	 * the files are before they are downloaded.
	 * @property _numItems
	 * @type {Number}
	 * @default 0
	 * @private
	 */
	p._numItems = 0;

	/**
	 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
	 * the files are before they are downloaded.
	 * @property _numItemsLoaded
	 * @type {Number}
	 * @default 0
	 * @private
	 */
	p._numItemsLoaded = 0;

	/**
	 * A list of scripts in the order they were requested. This helps ensure that scripts are &quot;completed&quot; in the right
	 * order.
	 * @property _scriptOrder
	 * @type {Array}
	 * @private
	 */
	p._scriptOrder = null;

	/**
	 * A list of scripts that have been loaded. Items are added to this list as &lt;code&gt;null&lt;/code&gt; when they are
	 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and &lt;code&gt;true&lt;/true&gt;
	 * once they are complete and have been dispatched.
	 * @property _loadedScripts
	 * @type {Array}
	 * @private
	 */
	p._loadedScripts = null;

	// Overrides abstract method in AbstractLoader
	p.init = function(useXHR, basePath, crossOrigin) {
		this._numItems = this._numItemsLoaded = 0;
		this._paused = false;
		this._loadStartWasDispatched = false;

		this._currentLoads = [];
		this._loadQueue = [];
		this._loadQueueBackup = [];
		this._scriptOrder = [];
		this._loadedScripts = [];
		this._loadItemsById = {};
		this._loadItemsBySrc = {};
		this._loadedResults = {};
		this._loadedRawResults = {};

		// Callbacks for plugins
		this._typeCallbacks = {};
		this._extensionCallbacks = {};

		this._basePath = basePath;
		this.setUseXHR(useXHR);
		this._crossOrigin = (crossOrigin === true)
				? &quot;Anonymous&quot; : (crossOrigin === false || crossOrigin == null)
				? &quot;&quot; : crossOrigin;
	};

	/**
	 * Change the usXHR value. Note that if this is set to true, it may fail depending on the browser&#x27;s capabilities.
	 * Additionally, some files require XHR in order to load, such as JSON (without JSONP), Text, and XML, so XHR will
	 * be used regardless of what is passed to this method.
	 * @method setUseXHR
	 * @param {Boolean} value The new useXHR value to set.
	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
	 * the provided value argument was true.
	 * @since 0.3.0
	 */
	p.setUseXHR = function(value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.useXHR = (value != false &amp;&amp; window.XMLHttpRequest != null);
		return this.useXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function() {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      queue.loadManifest([
	 *          {src:&quot;test.png&quot;, id:&quot;png&quot;},
	 *          {src:&quot;test.jpg&quot;, id:&quot;jpg&quot;},
	 *          {src:&quot;test.mp3&quot;, id:&quot;mp3&quot;}
	 *      ]);
	 *      queue.remove(&quot;png&quot;); // Single item by ID
	 *      queue.remove(&quot;png&quot;, &quot;test.jpg&quot;); // Items as arguments. Mixed id and src.
	 *      queue.remove([&quot;test.png&quot;, &quot;jpg&quot;]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function(idsOrUrls) {
		var args = null;

		if (idsOrUrls &amp;&amp; !(idsOrUrls instanceof Array)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length &gt; 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.useXHR);

		// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length-1;i&gt;=0;i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i,1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length-1;i&gt;=0;i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i,1)[0].cancel();
						break;
					}
				}

				if (r) {
					delete this._loadItemsById[r.id];
					delete this._loadItemsBySrc[r.src];
					this._disposeItem(r);
				} else {
					for (var i=this._currentLoads.length-1;i&gt;=0;i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i,1)[0].cancel();
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink &quot;AbstractLoader/load&quot;}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink &quot;LoadQueue/remove&quot;}}{{/crossLink}} or
	 * {{#crossLink &quot;LoadQueue/removeAll&quot;}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function() {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i=0, l=this._loadQueueBackup.length; i&lt;l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as &quot;binary&quot; are loaded as binary. Note that audio is &lt;b&gt;not&lt;/b&gt; a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @private
	 */
	s.isBinary = function(type) {
		switch (type) {
			case createjs.LoadQueue.IMAGE:
			case createjs.LoadQueue.BINARY:
				return true;
			default:
				return false;
		}
	};


	/**
	 * Determine if a specific type is a text based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @private
	 */
	s.isText = function(type) {
		switch (type) {
			case createjs.LoadQueue.TEXT:
			case createjs.LoadQueue.JSON:
			case createjs.LoadQueue.MANIFEST:
			case createjs.LoadQueue.XML:
			case createjs.LoadQueue.HTML:
			case createjs.LoadQueue.CSS:
			case createjs.LoadQueue.SVG:
			case createjs.LoadQueue.JAVASCRIPT:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a &lt;code&gt;getPreloadHandlers()&lt;/code&gt; method will be called on it. For more information
	 * on this method, check out the {{#crossLink &quot;SamplePlugin/getPreloadHandlers&quot;}}{{/crossLink}} method in the
	 * {{#crossLink &quot;SamplePlugin&quot;}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a &#x60;callback&#x60; is returned
	 * from the {{#crossLink &quot;SamplePlugin/getPreloadHandlers&quot;}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a &#x60;completeHandler&#x60; to be fired when
	 * the file is loaded, or a &#x60;tag&#x60; object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink &quot;SamplePlugin/preloadHandler&quot;}}{{/crossLink}} and {{#crossLink &quot;SamplePlugin/fileLoadHandler&quot;}}{{/crossLink}}
	 * methods on the {{#crossLink &quot;SamplePlugin&quot;}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function(plugin) {
		if (plugin == null || plugin.getPreloadHandlers == null) { return; }
		var map = plugin.getPreloadHandlers();
		map.scope = plugin;

		if (map.types != null) {
			for (var i=0, l=map.types.length; i&lt;l; i++) {
				this._typeCallbacks[map.types[i]] = map;
			}
		}
		if (map.extensions != null) {
			for (i=0, l=map.extensions.length; i&lt;l; i++) {
				this._extensionCallbacks[map.extensions[i]] = map;
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink &quot;LoadQueue/maintainScriptOrder:property&quot;}}{{/crossLink}}
	 * is &#x60;true&#x60;, only one script is loaded at a time due to browser limitations.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused &amp;&amp; this._loadQueue.length &gt; 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink &quot;AbstractLoader/close&quot;}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {Object | String} file The file object or path to load. A file can be either
     * &lt;ul&gt;
     *     &lt;li&gt;A string path to a resource. Note that this kind of load item will be converted to an object (see below)
	 *     in the background.&lt;/li&gt;
     *     &lt;li&gt;OR an object that contains:&lt;ul&gt;
     *         &lt;li&gt;src: The source of the file that is being loaded. This property is &lt;b&gt;required&lt;/b&gt;. The source can
	 *         either be a string (recommended), or an HTML tag.&lt;/li&gt;
     *         &lt;li&gt;type: The type of file that will be loaded (image, sound, json, etc). PreloadJS does auto-detection
	 *         of types using the extension. Supported types are defined on LoadQueue, such as &lt;code&gt;LoadQueue.IMAGE&lt;/code&gt;.
	 *         It is recommended that a type is specified when a non-standard file URI (such as a php script) us used.&lt;/li&gt;
     *         &lt;li&gt;id: A string identifier which can be used to reference the loaded object.&lt;/li&gt;
	 *         &lt;li&gt;callback: Optional, used for JSONP requests, to define what method to call when the JSONP is loaded.&lt;/li&gt;
     *         &lt;li&gt;data: An arbitrary data object, which is included with the loaded object&lt;/li&gt;
	 *         &lt;li&gt;method: used to define if this request uses GET or POST when sending data to the server. The default
	 *         value is &quot;GET&quot;&lt;/li&gt;
	 *         &lt;li&gt;values: Optional object of name/value pairs to send to the server.&lt;/li&gt;
     *     &lt;/ul&gt;
     * &lt;/ul&gt;
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink &quot;LoadQueue/setPaused&quot;}}{{/crossLink}}, and the value is
	 * &#x60;true&#x60;, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink &quot;LoadQueue/MANIFEST:property&quot;}}{{/crossLink}},
	 * its files will &lt;strong&gt;NOT&lt;/strong&gt; use the basePath parameter. &lt;strong&gt;The basePath parameter is deprecated.&lt;/strong&gt;
	 * This parameter will be removed in a future version. Please either use the &#x60;basePath&#x60; parameter in the LoadQueue
	 * constructor, or a &#x60;path&#x60; property in a manifest definition.
	 */
	p.loadFile = function(file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.Event(&quot;error&quot;);
			event.text = &quot;PRELOAD_NO_FILE&quot;;
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink &quot;LoadQueue/maintainScriptOrder&quot;}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink &quot;AbstractLoader/close&quot;}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * &lt;ol&gt;
	 *     &lt;li&gt;A string path, which points to a manifest file, which is a JSON file that contains a &quot;manifest&quot; property,
	 *     which defines the list of files to load, and can optionally contain a &quot;path&quot; property, which will be
	 *     prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An object which defines a &quot;src&quot;, which is a JSON or JSONP file. A &quot;callback&quot; can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a &quot;manifest&quot; property, which defines the list of files to load,
	 *     and can optionally contain a &quot;path&quot; property, which will be prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An object which contains a &quot;manifest&quot; property, which defines the list of files to load, and can
	 *     optionally contain a &quot;path&quot; property, which will be prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An Array of files to load.&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * Each &quot;file&quot; in a manifest can be either:
	 * &lt;ul&gt;
	 *     &lt;li&gt;A string path to a resource (string). Note that this kind of load item will be converted to an object
	 *     (see below) in the background.&lt;/li&gt;
	 *      &lt;li&gt;OR an object that contains:&lt;ul&gt;
	 *         &lt;li&gt;src: The source of the file that is being loaded. This property is &lt;b&gt;required&lt;/b&gt;. The source can
	 *         either be a string (recommended), or an HTML tag.&lt;/li&gt;
	 *         &lt;li&gt;type: The type of file that will be loaded (image, sound, json, etc). PreloadJS does auto-detection
	 *         of types using the extension. Supported types are defined on LoadQueue, such as &lt;code&gt;LoadQueue.IMAGE&lt;/code&gt;.
	 *         It is recommended that a type is specified when a non-standard file URI (such as a php script) us used.&lt;/li&gt;
	 *         &lt;li&gt;id: A string identifier which can be used to reference the loaded object.&lt;/li&gt;
	 *         &lt;li&gt;callback: Optional, used for JSONP requests, to define what method to call when the JSONP is loaded.&lt;/li&gt;
	 *         &lt;li&gt;data: An arbitrary data object, which is included with the loaded object&lt;/li&gt;
	 *         &lt;li&gt;method: used to define if this request uses GET or POST when sending data to the server. The default
	 *         value is &quot;GET&quot;&lt;/li&gt;
	 *         &lt;li&gt;values: Optional object of name/value pairs to send to the server.&lt;/li&gt;
	 *     &lt;/ul&gt;
	 * &lt;/ul&gt;
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink &quot;LoadQueue/setPaused&quot;}}{{/crossLink}} and this value is
	 * &#x60;true&#x60;, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink &quot;LoadQueue/MANIFEST:property&quot;}}{{/crossLink}},
	 * its files will &lt;strong&gt;NOT&lt;/strong&gt; use the basePath parameter. &lt;strong&gt;The basePath parameter is deprecated.&lt;/strong&gt;
	 * This parameter will be removed in a future version. Please either use the &#x60;basePath&#x60; parameter in the LoadQueue
	 * constructor, or a &#x60;path&#x60; property in a manifest definition.
	 */
	p.loadManifest = function(manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (manifest instanceof Array) {
			if (manifest.length == 0) {
				var event = new createjs.Event(&quot;error&quot;);
				event.text = &quot;PRELOAD_MANIFEST_EMPTY&quot;;
				this._sendError(event);
				return;
			}
			fileList = manifest;

		// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === &quot;string&quot;) {
			fileList = [{
				src: manifest,
				type: s.MANIFEST
			}];

		} else if (typeof(manifest) == &quot;object&quot;) {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.Event(&quot;error&quot;);
					event.text = &quot;PRELOAD_MANIFEST_ERROR&quot;;
					this._sendError(event);
				}
				fileList = [manifest];

			// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

		// Unsupported. This will throw an error.
		} else {
			var event = new createjs.Event(&quot;error&quot;);
			event.text = &quot;PRELOAD_MANIFEST_NULL&quot;;
			this._sendError(event);
			return;
		}

		for (var i=0, l=fileList.length; i&lt;l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	// Overrides abstract method in AbstractLoader
	p.load = function() {
		this.setPaused(false);
	};

	/**
	 * Look up a load item using either the &quot;id&quot; or &quot;src&quot; that was specified when loading it. Note that if no &quot;id&quot; was
	 * supplied with the load item, the ID will be the &quot;src&quot;, including a &#x60;path&#x60; property defined by a manifest. The
	 * &#x60;basePath&#x60; will not be part of the ID.
	 * @method getItem
	 * @param {String} value The &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}. This object is also returned via the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}
	 * event as the &#x60;item&#x60; parameter.
	 */
	p.getItem = function(value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the &quot;id&quot; or &quot;src&quot; that was specified when loading it. Note that if no &quot;id&quot;
	 * was supplied with the load item, the ID will be the &quot;src&quot;, including a &#x60;path&#x60; property defined by a manifest. The
	 * &#x60;basePath&#x60; will not be part of the ID.
	 * @method getResult
	 * @param {String} value The &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
     * &lt;ul&gt;
	 *      &lt;li&gt;An image tag (&amp;lt;image /&amp;gt;) for images&lt;/li&gt;
	 *      &lt;li&gt;A script tag for JavaScript (&amp;lt;script /&amp;gt;). Note that scripts are automatically added to the HTML
	 *      DOM.&lt;/li&gt;
	 *      &lt;li&gt;A style tag for CSS (&amp;lt;style /&amp;gt; or &amp;lt;link &amp;gt;)&lt;/li&gt;
	 *      &lt;li&gt;Raw text for TEXT&lt;/li&gt;
	 *      &lt;li&gt;A formatted JavaScript object defined by JSON&lt;/li&gt;
	 *      &lt;li&gt;An XML document&lt;/li&gt;
	 *      &lt;li&gt;A binary arraybuffer loaded by XHR&lt;/li&gt;
	 *      &lt;li&gt;An audio tag (&amp;lt;audio &amp;gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.&lt;/li&gt;
	 * &lt;/ul&gt;
     * This object is also returned via the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}  event as the &#x27;item&#x60;
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function(value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) { return null; }
		var id = item.id;
		if (rawResult &amp;&amp; this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}},
	 * a paused queue will be resumed, unless the &#x60;loadNow&#x60; argument is &#x60;false&#x60;.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function(value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	// Overrides abstract method in AbstractLoader
	p.close = function() {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
	};


//Protected Methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink &quot;LoadQueue.getItem&quot;}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the &#x60;src&#x60;. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as &#x60;http://&#x60;, or a path like &#x60;../&#x60;. If the LoadQueue was
	 * provided a {{#crossLink &quot;_basePath&quot;}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] &lt;strong&gt;Deprecated&lt;/strong&gt;An optional basePath passed into a {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function(value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) { return; } // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if (this.maintainScriptOrder
					&amp;&amp; item.type == createjs.LoadQueue.JAVASCRIPT
					&amp;&amp; loader instanceof createjs.XHRLoader) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined load item, which contains all the required properties (src, type, extension, tag). The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
 	 * @param {String} [path] A path to prepend to the item&#x27;s source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the &#x60;path&#x60; and {{#crossLink &quot;LoadQueue/_basePath:property&quot;}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] &lt;strong&gt;Deprectated&lt;/strong&gt; A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function(value, path, basePath) {
		var item = null;

		// Create/modify a load item
		switch(typeof(value)) {
			case &quot;string&quot;:
				item = {
					src: value
				}; break;
			case &quot;object&quot;:
				if (window.HTMLAudioElement &amp;&amp; value instanceof window.HTMLAudioElement) {
					item = {
						tag: value,
						src: item.tag.src,
						type: createjs.LoadQueue.SOUND
					};
				} else {
					item = value;
				}
				break;
			default:
				return null;
		}

		// Determine Extension, etc.
		var match = this._parseURI(item.src);
		if (match != null) { item.ext = match[6]; }
		if (item.type == null) {
			item.type = this._getTypeByExtension(item.ext);
		}

		// Inject path &amp; basePath
		var bp = &quot;&quot;; // Store the generated basePath
		var useBasePath = basePath || this._basePath;
		var autoId = item.src;
		if (match &amp;&amp; match[1] == null &amp;&amp; match[3] == null) {
			if (path) {
				bp = path;
				var pathMatch = this._parsePath(path);
				autoId = path + autoId;
				// Also append basePath
				if (useBasePath != null &amp;&amp; pathMatch &amp;&amp; pathMatch[1] == null &amp;&amp; pathMatch[2] == null) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		}
		item.src = bp + item.src;
		item.path = bp;

		if (item.type == createjs.LoadQueue.JSON || item.type == createjs.LoadQueue.MANIFEST) {
			item._loadAsJSONP = (item.callback != null);
		}

		if (item.type == createjs.LoadQueue.JSONP &amp;&amp; item.callback == null) {
			throw new Error(&#x27;callback is required for loading JSONP requests.&#x27;);
		}

		// Create a tag for the item. This ensures there is something to either load with or populate when finished.
		if (item.tag === undefined || item.tag === null) {
			item.tag = this._createTag(item);
		}

		// If there&#x27;s no id, set one now.
		if (item.id === undefined || item.id === null || item.id === &quot;&quot;) {
            item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item.src, item.type, item.id, item.data,
					bp, this);
			// NOTE: BasePath argument is deprecated. We pass it to plugins.allow SoundJS to modify the file. to sanymore. The full path is sent to the plugin

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

			// Load as normal:
			} else if (result === true) {
				// Do Nothing

			// Result is a loader class:
			} else {
				if (result.src != null) { item.src = result.src; }
				if (result.id != null) { item.id = result.id; } // TODO: Evaluate this. An overridden ID could be problematic
				if (result.tag != null) { // Assumes that the returned tag either has a load method or a src setter.
					item.tag = result.tag;
				}
                if (result.completeHandler != null) { item.completeHandler = result.completeHandler; }

				// Allow type overriding:
				if (result.type) { item.type = result.type; }

				// Update the extension in case the type changed:
				match = this._parseURI(item.src);
				if (match != null &amp;&amp; match[6] != null) {
					item.ext = match[6].toLowerCase();
				}
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function(item) {
		// Initially, try and use the provided/supported XHR mode:
		var useXHR = this.useXHR;

		// Determine the XHR usage overrides:
		switch (item.type) {
			case createjs.LoadQueue.JSON:
			case createjs.LoadQueue.MANIFEST:
				useXHR = !item._loadAsJSONP;
				break;
			case createjs.LoadQueue.XML:
			case createjs.LoadQueue.TEXT:
				useXHR = true; // Always use XHR2 with text/XML
				break;
			case createjs.LoadQueue.SOUND:
			case createjs.LoadQueue.JSONP:
				useXHR = false; // Never load audio using XHR. WebAudio will provide its own loader.
				break;
			case null:
				return null;
			// Note: IMAGE, CSS, SCRIPT, SVG can all use TAGS or XHR.
		}

		if (useXHR) {
			return new createjs.XHRLoader(item, this._crossOrigin);
		} else {
			return new createjs.TagLoader(item);
		}
	};


	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will &quot;fill up&quot; any empty slots, up to the max connection specified using
	 * {{#crossLink &quot;LoadQueue.setMaxConnections&quot;}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function() {
		if (this._paused) { return; }

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next &amp;&amp; this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i=0; i&lt;this._loadQueue.length; i++) {
			if (this._currentLoads.length &gt;= this._maxConnections) { break; }
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one at a time:
			if (this.maintainScriptOrder
					&amp;&amp; loader instanceof createjs.TagLoader
					&amp;&amp; loader.getItem().type == createjs.LoadQueue.JAVASCRIPT) {
				if (this._currentlyLoadingScript) { continue; } // Later items in the queue might not be scripts.
				this._currentlyLoadingScript = true;
			}
			this._loadQueue.splice(i, 1);
  			i--;
            this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Events are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function(loader) {
		loader.on(&quot;progress&quot;, this._handleProgress, this);
		loader.on(&quot;complete&quot;, this._handleFileComplete, this);
		loader.on(&quot;error&quot;, this._handleFileError, this);
		this._currentLoads.push(loader);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink &quot;LoadQueue/stopOnError:property&quot;}}{{/crossLink}}
	 * is set to &#x60;true&#x60;.
	 * @method _handleFileError
	 * @param {Object} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleFileError = function(event) {
		var loader = event.target;
		this._numItemsLoaded++;
		this._updateProgress();

		var newEvent = new createjs.Event(&quot;error&quot;);
		newEvent.text = &quot;FILE_LOAD_ERROR&quot;;
		newEvent.item = loader.getItem();
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._loadNext();
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the &quot;result&quot; property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the &quot;rawResult&quot; event, and can also be looked up using {{#crossLink &quot;LoadQueue/getResult&quot;}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Object} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function(event) {
		var loader = event.target;
		var item = loader.getItem();

		this._loadedResults[item.id] = loader.getResult();
		if (loader instanceof createjs.XHRLoader) {
			this._loadedRawResults[item.id] = loader.getResult(true);
		}

		this._removeLoadItem(loader);

		// Ensure that script loading happens in the right order.
		if (this.maintainScriptOrder &amp;&amp; item.type == createjs.LoadQueue.JAVASCRIPT) {
			if (loader instanceof createjs.TagLoader) {
				this._currentlyLoadingScript = false;
			} else {
				this._loadedScripts[createjs.indexOf(this._scriptOrder, item)] = item;
				this._checkScriptLoadOrder(loader);
				return;
			}
		}

		// Clean up the load item
		delete item._loadAsJSONP;

		// If the item was a manifest, then
		if (item.type == createjs.LoadQueue.MANIFEST) {
			var result = loader.getResult();
			if (result != null &amp;&amp; result.manifest !== undefined) {
				this.loadManifest(result, true);
			}
		}

		this._processFinishedLoad(item, loader);
	};

	/**
	 * @method _processFinishedLoad
	 * @param {Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function(item, loader) {
		// Old handleFileTagComplete follows here.
		this._numItemsLoaded++;

		this._updateProgress();
		this._sendFileComplete(item, loader);

		this._loadNext();
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a &quot;null&quot; value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to &lt;code&gt;true&lt;/code&gt;. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a &lt;code&gt;null&lt;/code&gt; value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i=0;i&lt;l;i++) {
			var item = this._loadedScripts[i];
			if (item === null) { break; } // This is still loading. Do not process further.
			if (item === true) { continue; } // This has completed, and been processed. Move on.

			// Append script tags to the head automatically. Tags do this in the loader, but XHR scripts have to maintain order.
			var loadItem = this._loadedResults[item.id];
			(document.body || document.getElementsByTagName(&quot;body&quot;)[0]).appendChild(loadItem);

			this._processFinishedLoad(item);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function(loader) {
		var l = this._currentLoads.length;
		for (var i=0;i&lt;l;i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i,1); break;
			}
		}
	};

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue overall progress.
	 * @method _handleProgress
	 * @param {Object} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function(event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don&#x27;t know the actual filesize of items before they are
	 * loaded, and even then we can only get the size of items loaded with XHR. In this case, we define a &quot;slot&quot; for
	 * each item (1 item in 10 would get 10%), and then append loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:&lt;ul&gt;
	 *      &lt;li&gt;5/10 of the items in the queue (50%)&lt;/li&gt;
	 *      &lt;li&gt;plus 20% of item 6&#x27;s slot (2%)&lt;/li&gt;
	 *      &lt;li&gt;equals 52%&lt;/li&gt;&lt;/ul&gt;
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems-this._numItemsLoaded;
		if (remaining &gt; 0) {
			var chunk = 0;
			for (var i=0, l=this._currentLoads.length; i&lt;l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining/this._numItems);
		}
		this._sendProgress(loaded);
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function(item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};


	/**
	 * Create an HTML tag. This is in LoadQueue instead of {{#crossLink &quot;TagLoader&quot;}}{{/crossLink}} because no matter
	 * how we load the data, we may need to return it in a tag.
	 * @method _createTag
	 * @param {String} type The item type. Items are passed in by the developer, or deteremined by the extension.
	 * @return {HTMLImageElement|HTMLAudioElement|HTMLScriptElement|HTMLLinkElement|Object} The tag that is created.
	 * Note that tags are not appended to the HTML body.
	 * @private
	 */
	p._createTag = function(item) {
		var tag = null;
		switch (item.type) {
			case createjs.LoadQueue.IMAGE:
				tag = document.createElement(&quot;img&quot;);
				if (this._crossOrigin != &quot;&quot; &amp;&amp; !this._isLocal(item)) { tag.crossOrigin = this._crossOrigin; }
				return tag;
			case createjs.LoadQueue.SOUND:
				tag = document.createElement(&quot;audio&quot;);
				tag.autoplay = false;
				// Note: The type property doesn&#x27;t seem necessary.
				return tag;
			case createjs.LoadQueue.JSON:
			case createjs.LoadQueue.JSONP:
			case createjs.LoadQueue.JAVASCRIPT:
			case createjs.LoadQueue.MANIFEST:
				tag = document.createElement(&quot;script&quot;);
				tag.type = &quot;text/javascript&quot;;
				return tag;
			case createjs.LoadQueue.CSS:
				if (this.useXHR) {
					tag = document.createElement(&quot;style&quot;);
				} else {
					tag = document.createElement(&quot;link&quot;);
				}
				tag.rel  = &quot;stylesheet&quot;;
				tag.type = &quot;text/css&quot;;
				return tag;
			case createjs.LoadQueue.SVG:
				if (this.useXHR) {
					tag = document.createElement(&quot;svg&quot;);
				} else {
					tag = document.createElement(&quot;object&quot;);
					tag.type = &quot;image/svg+xml&quot;;
				}
				return tag;
		}
		return null;
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, &lt;code&gt;LoadQueue.IMAGE&lt;/code&gt; or null if it can not be
	 * determined by the extension.
	 * @private
	 */
	p._getTypeByExtension = function(extension) {
		if (extension == null) {
			return createjs.LoadQueue.TEXT;
		}
		switch (extension.toLowerCase()) {
			case &quot;jpeg&quot;:
			case &quot;jpg&quot;:
			case &quot;gif&quot;:
			case &quot;png&quot;:
			case &quot;webp&quot;:
			case &quot;bmp&quot;:
				return createjs.LoadQueue.IMAGE;
			case &quot;ogg&quot;:
			case &quot;mp3&quot;:
			case &quot;wav&quot;:
				return createjs.LoadQueue.SOUND;
			case &quot;json&quot;:
				return createjs.LoadQueue.JSON;
			case &quot;xml&quot;:
				return createjs.LoadQueue.XML;
			case &quot;css&quot;:
				return createjs.LoadQueue.CSS;
			case &quot;js&quot;:
				return createjs.LoadQueue.JAVASCRIPT;
			case &#x27;svg&#x27;:
				return createjs.LoadQueue.SVG;
			default:
				return createjs.LoadQueue.TEXT;
		}
	};

	/**
	 * Dispatch a fileprogress event (and onFileProgress callback). Please see the &lt;code&gt;LoadQueue.fileprogress&lt;/code&gt;
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function(item, progress) {
		if (this._isCanceled()) {
			this._cleanUp();
			return;
		}
		if (!this.hasEventListener(&quot;fileprogress&quot;)) { return; }

		var event = new createjs.Event(&quot;fileprogress&quot;);
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload event. Please see the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {Object} item The item that is being loaded.
	 * @param {TagLoader | XHRLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function(item, loader) {
		if (this._isCanceled()) { return; }

		var event = new createjs.Event(&quot;fileload&quot;);
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

        // This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
        if (item.completeHandler) {
            item.completeHandler(event);
        }

		this.hasEventListener(&quot;fileload&quot;) &amp;&amp; this.dispatchEvent(event)
	};

	/**
	 * Dispatch a filestart event immediately before a file starts to load. Please see the {{#crossLink &quot;LoadQueue/filestart:event&quot;}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileStart
	 * @param {Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function(item) {
		var event = new createjs.Event(&quot;filestart&quot;);
		event.item = item;
		this.hasEventListener(&quot;filestart&quot;) &amp;&amp; this.dispatchEvent(event);
	};

	/**
	 * REMOVED.  Use createjs.proxy instead
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @static
	 * @private
	 * @deprecated In favour of the createjs.proxy method (see LoadQueue source).
	 */

	p.toString = function() {
		return &quot;[PreloadJS LoadQueue]&quot;;
	};

	createjs.LoadQueue = LoadQueue;


// Helper methods

	// An additional module to determine the current browser, version, operating system, and other environmental variables.
	var BrowserDetect = function() {}

	BrowserDetect.init = function() {
		var agent = navigator.userAgent;
		BrowserDetect.isFirefox = (agent.indexOf(&quot;Firefox&quot;) &gt; -1);
		BrowserDetect.isOpera = (window.opera != null);
		BrowserDetect.isChrome = (agent.indexOf(&quot;Chrome&quot;) &gt; -1);
		BrowserDetect.isIOS = agent.indexOf(&quot;iPod&quot;) &gt; -1 || agent.indexOf(&quot;iPhone&quot;) &gt; -1 || agent.indexOf(&quot;iPad&quot;) &gt; -1;
	};

	BrowserDetect.init();

	createjs.LoadQueue.BrowserDetect = BrowserDetect;

}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
